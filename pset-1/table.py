"""Utilities to generate a nice-looking table from some data and column headers.

The table generated by this program has the following properties:
    * The first line has column headers
    * The second line consists of underlines for those column headers
    * The rest of the lines of the table contain formatted rows of the table
        * Format specifiers are in the FormatSpec class; the format_str argument to Table.__init__
        should be a string of those letters (currently 'p', 'w', or 't').
"""

import shutil
from enum import Enum
import textwrap


class FormatSpec(Enum):
    """Enum class for format specifiers for the columns in the table.

    Values:
        PREFORMATTED columns will not have their widths changed. They will be separated into
            several lines by splitting at each PREFORMAT_SEPARATOR character occurence.
        WRAPPED columns will be wrapped at word boundaries to the appropriate width.
        TRUNCATED columns will have their values truncated to the appropriate width, with a
            trailing ellipsis.
    """

    PREFORMATTED = 'p'
    WRAPPED = 'w'
    TRUNCATED = 't'


class Table:
    """Class for formatting data in an ASCII table.

    The Table class is:
        immutable. Therefore it is imperative to generate all data before creating a table.
        addressable. To print the x-th data row in a table, use:
            print(a_table[x])
        iterable. To print every data row in a table, use:
            for row in a_table:
                print(row)

    The statment a_table.header() is the same as a_table[-1].

    NOTE: This is an incomplete class. Some functions are implemented while others are not. Should
        you choose to use this scaffolding, you must implement the following functions, each marked
        by a "TODO" comment:
            * lines_for_row(self, row_idx)
            * headers(self)
            * __str__(self)
    """

    _LINE_LENGTH = min(80, shutil.get_terminal_size(fallback=(80, 50))[0])
    _HEAD_UNDERLINE = "-"
    _COLUMN_SEPARATOR = " "
    _PREFORMAT_SEPARATOR = "|"
    _DOTS = "..."

    def __init__(self, column_names: list[str], data: list[list[str]], *,
                 head_underline: str = None,
                 col_sep: str = None,
                 format_str: str = None,
                 max_width: int = None) -> None:
        """Initializer for Table class.

        Required positional parameters:
            column_names:
                A list of strings to use as column headers in the table.
            data:
                A list, each item of which is itself a list of strings with the same length as
                column_names

        Optional keyword parameters:
            head_underline:
                The character to use as the header underline. Default is HEAD_UNDERLINE.
            col_sep:
                The string to use as a separator between columns. Default is COLUMN_SEPARATOR.
            format_str:
                Describes how to format each column of the table. Default wraps every column.
            max_width:
                The maximum width of the entire table. Used when computing column widths.

        NOTE: This function is implemented for you.
        """

        self._column_names = column_names
        self._data = data
        self._head_underline = head_underline or Table._HEAD_UNDERLINE
        self._col_sep = col_sep or Table._COLUMN_SEPARATOR
        if format_str:
            self._format_spec = [FormatSpec(fmt) for fmt in format_str]
        else:
            self._format_spec = ([FormatSpec.WRAPPED] * len(column_names))
        self._max_width = max_width or Table._LINE_LENGTH
        self._column_widths = []

    @property
    def column_widths(self, *, recompute=False) -> list[int]:
        """Computes and returns appropriate column widths for the column names and data.

        This computation is done via the following algorithm:
            1. Compute the longest value in each column
            2. If the total width > self._max_width, then:
                a. Truncate last column such that total width <= self._max_width
                b. If the last column is too narrow, then REDISTRIBUTE.

        The REDISTRIBUTE algorithm is as follows:
            1. Repeatedly remove characters from the widest column that is wider than its header
                until enough characters have been redistributed or all columns are the same width
                as their headers (in which case, we will have a table wider than self._max_width).

        NOTE: This function is implemented for you because its correctness has an outsized impact on
            the autograding script we will be running. It is also quite intricate; we recommend
            trying to implement this on your own as a fun exercise.
        """

        if recompute or not self._column_widths:
            # Preliminary computation of the width of each column as the length of the longer of:
            #   - the longest value in that column
            #   - the length of the column name

            columns = tuple(zip(self._column_names, *self._data))
            for fmt, column in zip(self._format_spec, columns):
                # A PREFORMATTED column needs special treatment. A PREFORMATTED column actually
                # contains several lines before any wrapping functions are applied; we want the
                # longest of those lines.
                if fmt == FormatSpec.PREFORMATTED:
                    col_lines = []
                    for row in column:
                        col_lines += (str(x)
                                      for x in row.split(Table._PREFORMAT_SEPARATOR))
                    width = max(len(line) for line in col_lines)
                else:
                    width = max((len(str(line)) for line in column))
                self._column_widths.append(width)

            # Redistribute the columns so they fit in self._max_width
            self._column_widths = self._redistribute_widths()

        return self._column_widths

    @column_widths.setter
    def set_column_widths(self, col_widths: list[int]):
        """Setter for column_widths property, providing the capability to manually set the widths
            of columns in a Table.

        NOTE: This function is implemented for you.
        """

        self._column_widths = col_widths

    def lines_for_row(self, row_idx: int) -> list[str]:
        """Generates the lines of text needed to print row row_idx with appropriate formatting.

        Parameters:
            row_idx:
                The index of the row in data to format; a negative index indicates the header row,
                and the returned value includes the underline.
        """

        # TODO: Implement this function.
        result = ''

        row = self._data[row_idx]
        # convert any int or other type to string for formatting
        row = [str(data) for data in row]

        # create lists of wrapped texts for each attribute
        for i, attribute in enumerate(row):
            if i != 4:
                row[i] = textwrap.wrap(attribute, self.column_widths[i])
            else:
                row[i] = attribute.split(self._PREFORMAT_SEPARATOR)

        # the max number of lines needed for this row of data
        max_line = max([len(i) for i in row])

        count = 0
        # while lines of this row has not ended
        while count < max_line:
            # loop over each attribute
            for i, attribute in enumerate(row):
                # if there is still wrapped text left, format it
                if count < len(attribute):
                    result += attribute[count]
                    # if this line of wrapped text is within the column width, append with space
                    if len(attribute[count]) < self.column_widths[i]:
                        result += self._col_sep * (self.column_widths[i] - len(attribute[count]))
                    # if not last attribute, add space
                    # else start a new line
                    if i < len(row) - 1:
                        result += self._col_sep
                    else:
                        result += "\n"
                # if there is no text left to wrap for this attribute, fill the empty space
                else:
                    if i < len(row) - 1:
                        result += self._col_sep * self.column_widths[i]
                        result += self._col_sep
                    else:
                        result += self._col_sep * self.column_widths[i]
                        result += "\n"
            count += 1

        return result

    def headers(self) -> list[str]:
        """Returns list of two strings containing headers and the underline for this Table."""

        # TODO: Implement this function
        headers = ''
        underline = ''

        for i, width in enumerate(self.column_widths):
            headers += self._column_names[i]
            headers += self._col_sep * (width - len(self._column_names[i]))
            headers += self._col_sep
        headers = headers[:-1]
        headers += "\n"

        for width in  self.column_widths:
            underline += width * self._head_underline
            underline += self._col_sep
        underline = underline[:-1]
        underline += "\n"

        return [headers, underline]

    def __str__(self) -> str:
        """Returns a string that, when printed, displays a table no wider than max_width with each 
            row containing the values from one element of data. It has the following properties.
                * The first line of the table contains the names of the columns, left-aligned in
                    their respective fields    
                * The second line of input is a sequence of blocks of head_underline characters,
                    each as wide as the respective column, and each separated by a col_sep
                    character.
                * The reamaining lines of the table are the rows of data, each value formatted
                    according to the formatspec string (described below). Note that this means some
                    rows of data will span multiple lines in the returned string.
        """

        # TODO: Implement this function
        result = ''

        headers, underline = self.headers()
        result += headers
        result += underline

        for i in range(len(self._data)):
            result += self.lines_for_row(i)

        result = result[:len(result) - 1]  # remove the last new line ("\n")

        return result

    def __getitem__(self, row_idx: int) -> str:
        """Enables the use of accessor syntax ([...]) on a Table.

        NOTE: This function is implemented for you.
        """

        return self.lines_for_row(row_idx)

    def __len__(self):
        """Returns the number of data rows in this table.

        NOTE: This function is implemented for you.
        """

        return len(self._data)

    def __iter__(self):
        """Returns an iterator for formatted rows of data in this table (does not include the
            header row).

        NOTE: This function is implemented for you.
        """

        self._iter_cnt = 0
        return self

    def __next__(self):
        """Returns the next row of data in this table as a formatted row.

        NOTE: This function is implemented for you.
        """

        next = self[self._iter_cnt]
        self._iter_cnt += 1
        if self._iter_cnt == len(self):
            raise StopIteration
        return next

# **************************************
# *           BEGIN PRIVATE            *
# **************************************

    def _total_width(self, *, column_sep=_COLUMN_SEPARATOR) -> int:
        """Computes and returns the total width of the table."""

        width = sum(self.column_widths) + \
            (len(column_sep) * (len(self.column_widths)-1))
        return width

    def _redistribute_widths(self):
        """Redistributes the column widths according to the algorithm described in column_widths.

        NOTE: This function (including its nested helpers) is implemented for you because its
            correctness has an outsized impact on the autograding script we will be running. It is
            also quite intricate; we recommend trying to implement this on your own as a fun
            exercise.
        """

        # Truncate the rightmost column
        redistributed_widths = list(self._column_widths)
        redistributed_widths[-1] = min(
            redistributed_widths[-1],
            self._max_width
            - (self._total_width() - redistributed_widths[-1])
            - (len(self._col_sep) - 1))

        # Helper function for REDISRIBUTE algorithm
        def column_is_wide_enough(
                width: int, header: str, format_spec: FormatSpec, nominal_width: int):
            """Returns true iff this column is "wide enough".

            That is, returns True iff the column is at least as wide as:
                * any line of its contents (aka nominal_width), if it is PREFORMATTED, or
                * its header, if it is WRAPPED, or
                * the greater of its header or 6 characters, if it is TRUNCATED.
            """

            match format_spec:
                case FormatSpec.WRAPPED:
                    return width >= len(header)
                case FormatSpec.PREFORMATTED:
                    return width >= nominal_width
                case FormatSpec.TRUNCATED:
                    return width >= max(len(header), 6)

            # This code should never be reached
            raise AssertionError

        # Helper function for REDISRIBUTE algorithm
        def next_reducable_column(widths):
            """Returns the index of the widest column that is wider than its header, or -1
                if no such column exists.
            """

            # Sort the widths in decreasing order, keeping track of their original indices
            sorted_idxes_and_widths = sorted(
                enumerate(widths), key=lambda t: t[1], reverse=True)

            idx = -1
            for i, width in sorted_idxes_and_widths:
                if column_is_wide_enough(
                        width,
                        self._column_names[i],
                        self._format_spec[i],
                        self._column_widths[i]):
                    idx = i
                    break

            return idx

        # Loop for REDISTRIBUTE algorithm.
        def last(iter):
            return iter[-1]

        while (to_reduce := next_reducable_column(redistributed_widths)) >= 0 and\
                not column_is_wide_enough(
                    last(redistributed_widths),
                    last(self._column_names),
                    last(self._format_spec),
                    last(self._column_widths)):
            assert to_reduce != len(redistributed_widths) - 1
            redistributed_widths[to_reduce] -= 1
            redistributed_widths[-1] += 1

        return redistributed_widths
